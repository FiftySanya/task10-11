# Process Creation у Linux

## Зміст
- [Завдання 1: Dumb Shell (Проста командна оболонка)](#завдання-1-dumb-shell-проста-командна-оболонка)
- [Завдання 2: Дослідження API `wait` та поняття Fork Bomb](#завдання-2-дослідження-api-wait-та-поняття-fork-bomb)
- [Завдання 3: Демонстрація `wait()` та довільного порядку завершення процесів](#завдання-3-демонстрація-wait-та-довільного-порядку-завершення-процесів)

---

## Завдання 1: Dumb Shell (Проста командна оболонка)

### Опис
Реалізація простої командної оболонки `dumbsh`, яка зчитує команди користувача, виконує їх у дочірніх процесах та очікує на їх завершення. Оболонка підтримує команду `exit` для виходу.

### Результати
```
./task1
dumbsh> ls
task1    task1.c
dumbsh> whoami
root
dumbsh> exit
```

### Пояснення
- Оболонка працює в безперервному циклі, виводячи запрошення `dumbsh> ` для введення команди.
- Команди зчитуються за допомогою системного виклику `fgets()`, після чого видаляється символ нового рядка.
- Вбудована команда `exit` обробляється окремо для завершення роботи оболонки.
- Для виконання зовнішніх команд:
    - Батьківський процес створює дочірній процес за допомогою системного виклику `fork()`.
    - **У дочірньому процесі:** Використовується `execlp()` для заміни образу процесу на вказану команду. `execlp` шукає виконуваний файл команди у каталогах, перелічених у змінній середовища `PATH`. Якщо `execlp` не вдається виконати команду (наприклад, команда не знайдена), виводиться повідомлення про помилку, і дочірній процес завершується зі статусом помилки.
    - **У батьківському процесі:** Використовується `wait(NULL)` для очікування завершення дочірнього процесу. Це забезпечує синхронне виконання команд: нова команда не запитується до завершення попередньої.
- **Обмеження:** Поточна реалізація `dumbsh` є базовою і не підтримує передачу аргументів командам (наприклад, `ls -l` буде інтерпретовано як спроба знайти команду з іменем "ls -l"). Також відсутні розширені функції оболонки.

### Висновки
- Проєкт успішно демонструє фундаментальний цикл роботи командної оболонки, що базується на послідовності системних викликів `fork()`, `exec()` (у даному випадку `execlp()`) та `wait()`.
- `execlp` є зручним способом запуску зовнішніх програм без необхідності вказувати повний шлях, покладаючись на `PATH`.
- `wait()` слугує механізмом синхронізації, що дозволяє батьківському процесу контролювати життєвий цикл дочірніх процесів.

## Завдання 2: Дослідження API `wait` та поняття Fork Bomb

### Опис
Ця програма створює три дочірні процеси, кожен з яких завершується з різною, наперед визначеною затримкою. Батьківський процес демонструє три основні способи очікування завершення цих дочірніх процесів:
1.  `wait(&status)`: очікування будь-якого дочірнього процесу.
2.  `waitpid(specific_pid, &status, 0)`: блокуюче очікування конкретного дочірнього процесу.
3.  `waitpid(-1, &status, WNOHANG)`: неблокуюча перевірка завершення будь-якого дочірнього процесу.

Також надається короткий опис небезпечного явища "Fork Bomb".

### Fork Bomb (Короткий опис)
- **Fork Bomb** – це тип атаки на відмову в обслуговуванні (DoS), де процес безперервно створює свої копії (використовуючи системний виклик `fork()` або аналогічний), що швидко вичерпує доступні системні ресурси, такі як ідентифікатори процесів та пам'ять.
- Запуск Fork Bomb може призвести до "зависання" системи або її повної непрацездатності, вимагаючи перезавантаження.

### Результати (демонстрація API `wait`)
```
БАТЬКІВСЬКИЙ (PID: 1083): Програма починається, створення 3 дочірніх процесів...
БАТЬКІВСЬКИЙ: Створено Дочірній 1 з PID 1084 (очікувана затримка 2 сек).
  ДОЧІРНІЙ 1 (PID: 1084): Створено. Працюватиму 2 сек. Мій код виходу: 10.
БАТЬКІВСЬКИЙ: Створено Дочірній 2 з PID 1085 (очікувана затримка 6 сек).
  ДОЧІРНІЙ 2 (PID: 1085): Створено. Працюватиму 6 сек. Мій код виходу: 20.
БАТЬКІВСЬКИЙ: Створено Дочірній 3 з PID 1086 (очікувана затримка 4 сек).

БАТЬКІВСЬКИЙ [Фаза 1]: Використання wait() для очікування БУДЬ-ЯКОГО дочірнього процесу.
БАТЬКІВСЬКИЙ: Очікую, що Дитина 1 (PID 1084, затримка 2s) завершиться першою.
  ДОЧІРНІЙ 3 (PID: 1086): Створено. Працюватиму 4 сек. Мій код виходу: 30.
  ДОЧІРНІЙ 1 (PID: 1084): Роботу завершено. Вихід.
БАТЬКІВСЬКИЙ [Фаза 1]: wait() повернув PID 1084.
БАТЬКІВСЬКИЙ: Дочірній процес PID 1084 завершився нормально з кодом 10.

БАТЬКІВСЬКИЙ [Фаза 2]: Використання waitpid() для очікування КОНКРЕТНО Дитини 3 (PID 1086, затримка 4s).
  ДОЧІРНІЙ 3 (PID: 1086): Роботу завершено. Вихід.
БАТЬКІВСЬКИЙ [Фаза 2]: waitpid(PID 1086) повернув PID 1086.
БАТЬКІВСЬКИЙ: Дочірній процес PID 1086 завершився нормально з кодом 30.

БАТЬКІВСЬКИЙ [Фаза 3]: Використання waitpid(-1, ..., WNOHANG) для неблокуючої перевірки решти.
БАТЬКІВСЬКИЙ: Очікую знайти Дитину 2 (початковий PID 1085, затримка 6s).
БАТЬКІВСЬКИЙ [Фаза 3]: (Спроба 1) Жоден дочірній процес не завершився. Виконую іншу роботу...
БАТЬКІВСЬКИЙ [Фаза 3]: (Спроба 2) Жоден дочірній процес не завершився. Виконую іншу роботу...
БАТЬКІВСЬКИЙ [Фаза 3]: (Спроба 3) Жоден дочірній процес не завершився. Виконую іншу роботу...
БАТЬКІВСЬКИЙ [Фаза 3]: (Спроба 4) Жоден дочірній процес не завершився. Виконую іншу роботу...
  ДОЧІРНІЙ 2 (PID: 1085): Роботу завершено. Вихід.
БАТЬКІВСЬКИЙ [Фаза 3]: waitpid() з WNOHANG зібрав PID 1085 на спробі 5.
БАТЬКІВСЬКИЙ: Дочірній процес PID 1085 завершився нормально з кодом 20.

БАТЬКІВСЬКИЙ: Завершення спроб "збору" дочірніх процесів.
БАТЬКІВСЬКИЙ: Всі 3 дочірні процеси були успішно "зібрані".
БАТЬКІВСЬКИЙ: Завершення програми
```

### Пояснення (демонстрація API `wait`)
- Програма створює трьох дочірніх процесів із затримками: Дитина 1 (2 секунди), Дитина 2 (6 секунд), Дитина 3 (4 секунди).
- **Фаза 1:** `wait(&status)` блокує батьківський процес і очікує на завершення будь-якого з дочірніх процесів. Оскільки Дитина 1 має найменшу затримку, вона завершується першою, і `wait()` повертає її PID.
- **Фаза 2:** `waitpid(pid_Дитини_3, &status, 0)` цілеспрямовано очікує на завершення Дитини 3. Батьківський процес блокується, доки Дитина 3 не завершить свою роботу (через 4 секунди від старту програми).
- **Фаза 3:** `waitpid(-1, &status, WNOHANG)` використовується для неблокуючого очікування решти дочірніх процесів (залишилася Дитина 2 із затримкою 6 секунд). Батьківський процес у циклі періодично перевіряє стан, "виконуючи іншу роботу" (симульовану через `usleep()`) між перевірками. `waitpid()` повертає 0, доки Дитина 2 не завершиться. Після її завершення `waitpid()` повертає PID Дитини 2.

### Висновки (демонстрація API `wait`)
- `wait()` є найпростішим способом блокуючого очікування на завершення будь-якого дочірнього процесу. Він повертає PID процесу в порядку їх фактичного завершення.
- `waitpid(pid, ..., 0)` дозволяє здійснювати блокуюче очікування завершення конкретного дочірнього процесу, що корисно для більш точного контролю.
- `waitpid(pid, ..., WNOHANG)` надає механізм неблокуючого опитування стану дочірніх процесів, що дозволяє батьківському процесу продовжувати виконання інших завдань, періодично перевіряючи, чи не завершився якийсь із дітей.

## Завдання 3: Демонстрація `wait()` та довільного порядку завершення процесів

### Опис
Програма створює п'ять дочірніх процесів. Кожен дочірній процес отримує унікальну випадкову затримку перед своїм завершенням (для забезпечення дійсно різних затримок кожен дочірній процес ініціалізує генератор випадкових чисел викликом `srand(time(NULL) ^ getpid())`). Батьківський процес використовує `wait()` у циклі для збору всіх завершених дочірніх процесів.

### Результати
```
БАТЬКІВСЬКИЙ ПРОЦЕС (PID: 1164): Починаю роботу.
БАТЬКІВСЬКИЙ: Створюю 5 дочірніх процесів...

БАТЬКІВСЬКИЙ: Створено дочірній процес з PID: 1165 (порядковий номер 0).
  ДОЧІРНІЙ (PID: 1165, Батько PPID: 1164): Створено. Затримка на 1 сек.
БАТЬКІВСЬКИЙ: Створено дочірній процес з PID: 1166 (порядковий номер 1).
  ДОЧІРНІЙ (PID: 1166, Батько PPID: 1164): Створено. Затримка на 4 сек.
БАТЬКІВСЬКИЙ: Створено дочірній процес з PID: 1167 (порядковий номер 2).
  ДОЧІРНІЙ (PID: 1167, Батько PPID: 1164): Створено. Затримка на 4 сек.
БАТЬКІВСЬКИЙ: Створено дочірній процес з PID: 1168 (порядковий номер 3).
БАТЬКІВСЬКИЙ: Створено дочірній процес з PID: 1169 (порядковий номер 4).

БАТЬКІВСЬКИЙ: Всі 5 дочірні процеси створено.
БАТЬКІВСЬКИЙ: Очікую на завершення дочірніх процесів...

  ДОЧІРНІЙ (PID: 1168, Батько PPID: 1164): Створено. Затримка на 5 сек.
  ДОЧІРНІЙ (PID: 1169, Батько PPID: 1164): Створено. Затримка на 1 сек.
  ДОЧІРНІЙ (PID: 1165): Завершую роботу. Код виходу: 0.
  ДОЧІРНІЙ (PID: 1169): Завершую роботу. Код виходу: 4.
БАТЬКІВСЬКИЙ: wait() повернув PID 1165.
БАТЬКІВСЬКИЙ: Дочірній процес PID 1165 завершився нормально. Код виходу: 0.
БАТЬКІВСЬКИЙ: Залишилося очікувати 4 дочірніх процесів.

БАТЬКІВСЬКИЙ: wait() повернув PID 1169.
БАТЬКІВСЬКИЙ: Дочірній процес PID 1169 завершився нормально. Код виходу: 4.
БАТЬКІВСЬКИЙ: Залишилося очікувати 3 дочірніх процесів.

  ДОЧІРНІЙ (PID: 1167): Завершую роботу. Код виходу: 2.
  ДОЧІРНІЙ (PID: 1166): Завершую роботу. Код виходу: 1.
БАТЬКІВСЬКИЙ: wait() повернув PID 1167.
БАТЬКІВСЬКИЙ: Дочірній процес PID 1167 завершився нормально. Код виходу: 2.
БАТЬКІВСЬКИЙ: Залишилося очікувати 2 дочірніх процесів.

БАТЬКІВСЬКИЙ: wait() повернув PID 1166.
БАТЬКІВСЬКИЙ: Дочірній процес PID 1166 завершився нормально. Код виходу: 1.
БАТЬКІВСЬКИЙ: Залишилося очікувати 1 дочірніх процесів.

  ДОЧІРНІЙ (PID: 1168): Завершую роботу. Код виходу: 3.
БАТЬКІВСЬКИЙ: wait() повернув PID 1168.
БАТЬКІВСЬКИЙ: Дочірній процес PID 1168 завершився нормально. Код виходу: 3.
БАТЬКІВСЬКИЙ: Залишилося очікувати 0 дочірніх процесів.


БАТЬКІВСЬКИЙ: Всі 5 дочірні процеси успішно завершено та зібрано.
БАТЬКІВСЬКИЙ ПРОЦЕС: Завершення роботи.
```

### Пояснення
- Батьківський процес створює 5 дочірніх процесів. Для генерації справді різних випадкових затримок кожен дочірній процес використовує `srand(time(NULL) ^ getpid())` для ініціалізації свого генератора випадкових чисел, після чого генерує затримку від 1 до 6 секунд.
- У наведеному прикладі виводу діти отримали такі затримки: PID 1165 (1с), PID 1166 (4с), PID 1167 (4с), PID 1168 (5с), PID 1169 (1с).
- Батьківський процес використовує цикл `while (wait(&status) > 0)` для очікування та збору всіх дочірніх процесів.
- Порядок "збору" дочірніх процесів батьківським процесом (1165, 1169, 1167, 1166, 1168) чітко відповідає порядку їхнього фактичного завершення згідно з отриманими затримками:
    - Спочатку були зібрані процеси з 1-секундною затримкою (PID 1165 та PID 1169).
    - Потім процеси з 4-секундною затримкою (PID 1167 та PID 1166).
    - Останнім був зібраний процес з 5-секундною затримкою (PID 1168).

### Висновки
- Використання `srand(time(NULL) ^ getpid())` у кожному дочірньому процесі є ефективним методом для забезпечення різних послідовностей випадкових чисел і, як наслідок, різних затримок.
- Системний виклик `wait()` дійсно повертає PID завершених дочірніх процесів у порядку їх фактичного завершення.
